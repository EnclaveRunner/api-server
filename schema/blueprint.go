// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"

type Blueprint struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion" yaml:"apiVersion" mapstructure:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Spec corresponds to the JSON schema field "spec".
	Spec Spec `json:"spec" yaml:"spec" mapstructure:"spec"`

	// Status corresponds to the JSON schema field "status".
	Status *Status `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Blueprint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["apiVersion"]; raw != nil && !ok {
		return fmt.Errorf("field apiVersion in Blueprint: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in Blueprint: required")
	}
	if _, ok := raw["metadata"]; raw != nil && !ok {
		return fmt.Errorf("field metadata in Blueprint: required")
	}
	if _, ok := raw["spec"]; raw != nil && !ok {
		return fmt.Errorf("field spec in Blueprint: required")
	}
	type Plain Blueprint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Blueprint(plain)
	return nil
}

type Metadata struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Metadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Metadata: required")
	}
	type Plain Metadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Metadata(plain)
	return nil
}

type Param struct {
	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Param) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in Param: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in Param: required")
	}
	type Plain Param
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Param(plain)
	return nil
}

type Spec struct {
	// Callback corresponds to the JSON schema field "callback".
	Callback *string `json:"callback,omitempty" yaml:"callback,omitempty" mapstructure:"callback,omitempty"`

	// Function corresponds to the JSON schema field "function".
	Function string `json:"function,omitempty" yaml:"function,omitempty" mapstructure:"function,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []Param `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`

	// Retention corresponds to the JSON schema field "retention".
	Retention *string `json:"retention,omitempty" yaml:"retention,omitempty" mapstructure:"retention,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source string `json:"source" yaml:"source" mapstructure:"source"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Spec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["source"]; raw != nil && !ok {
		return fmt.Errorf("field source in Spec: required")
	}
	type Plain Spec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["function"]; !ok || v == nil {
		plain.Function = "main"
	}
	*j = Spec(plain)
	return nil
}

type Status struct {
	// Created corresponds to the JSON schema field "created".
	Created string `json:"created" yaml:"created" mapstructure:"created"`

	// Events corresponds to the JSON schema field "events".
	Events []string `json:"events" yaml:"events" mapstructure:"events"`

	// Healthy corresponds to the JSON schema field "healthy".
	Healthy bool `json:"healthy" yaml:"healthy" mapstructure:"healthy"`

	// Revisions corresponds to the JSON schema field "revisions".
	Revisions int `json:"revisions" yaml:"revisions" mapstructure:"revisions"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Status) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["created"]; raw != nil && !ok {
		return fmt.Errorf("field created in Status: required")
	}
	if _, ok := raw["events"]; raw != nil && !ok {
		return fmt.Errorf("field events in Status: required")
	}
	if _, ok := raw["healthy"]; raw != nil && !ok {
		return fmt.Errorf("field healthy in Status: required")
	}
	if _, ok := raw["revisions"]; raw != nil && !ok {
		return fmt.Errorf("field revisions in Status: required")
	}
	type Plain Status
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Status(plain)
	return nil
}
